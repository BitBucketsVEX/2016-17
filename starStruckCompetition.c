#pragma config(Sensor, dgtl1,  shaft,          sensorQuadEncoder)
#pragma config(Motor,  port2,           frontRight,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port3,           frontLeft,     tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           backRight,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port5,           backLeft,      tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           arm1,          tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           arm2,          tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)


// Comment/uncomment this TEST_SIM flag to switch between real and emulation
//#define TEST_SIM

#ifndef TEST_SIM
	#include "Vex_Competition_Includes.c"
#else
  bool bStopTasksBetweenModes = true;
#endif

/*
     ___          __        ______   .__   __.   _______    .___________. __  .___  ___.  _______         ___       _______   ______
    /   \        |  |      /  __  \  |  \ |  |  /  _____|   |           ||  | |   \/   | |   ____|       /   \     /  _____| /  __  \
   /  ^  \       |  |     |  |  |  | |   \|  | |  |  __     `---|  |----`|  | |  \  /  | |  |__         /  ^  \   |  |  __  |  |  |  |
  /  /_\  \      |  |     |  |  |  | |  . `  | |  | |_ |        |  |     |  | |  |\/|  | |   __|       /  /_\  \  |  | |_ | |  |  |  |
 /  _____  \     |  `----.|  `--'  | |  |\   | |  |__| |        |  |     |  | |  |  |  | |  |____     /  _____  \ |  |__| | |  `--'  |  __ __ __
/__/     \__\    |_______| \______/  |__| \__|  \______|        |__|     |__| |__|  |__| |_______|   /__/     \__\ \______|  \______/  (__|__|__)
 __  .__   __.         ___           _______      ___       __          ___      ___   ___ ____    ____     _______    ___      .______
|  | |  \ |  |        /   \         /  _____|    /   \     |  |        /   \     \  \ /  / \   \  /   /    |   ____|  /   \     |   _  \
|  | |   \|  |       /  ^  \       |  |  __     /  ^  \    |  |       /  ^  \     \  V  /   \   \/   /     |  |__    /  ^  \    |  |_)  |
|  | |  . `  |      /  /_\  \      |  | |_ |   /  /_\  \   |  |      /  /_\  \     >   <     \_    _/      |   __|  /  /_\  \   |      /
|  | |  |\   |     /  _____  \     |  |__| |  /  _____  \  |  `----./  _____  \   /  .  \      |  |        |  |    /  _____  \  |  |\  \----.__
|__| |__| \__|    /__/     \__\     \______| /__/     \__\ |_______/__/     \__\ /__/ \__\     |__|        |__|   /__/     \__\ | _| `._____(_ )
                                                                                                                                             |/
 _______    ___      .______                 ___   ____    __    ____  ___   ____    ____
|   ____|  /   \     |   _  \               /   \  \   \  /  \  /   / /   \  \   \  /   /
|  |__    /  ^  \    |  |_)  |             /  ^  \  \   \/    \/   / /  ^  \  \   \/   /
|   __|  /  /_\  \   |      /             /  /_\  \  \            / /  /_\  \  \_    _/
|  |    /  _____  \  |  |\  \----.__     /  _____  \  \    /\    / /  _____  \   |  |  __ __ __
|__|   /__/     \__\ | _| `._____(_ )   /__/     \__\  \__/  \__/ /__/     \__\  |__| (__|__|__)
                                  |/
     _______.___________.    ___      .______              _______.___________..______       __    __    ______  __  ___
    /       |           |   /   \     |   _  \            /       |           ||   _  \     |  |  |  |  /      ||  |/  /
   |   (----`---|  |----`  /  ^  \    |  |_)  |          |   (----`---|  |----`|  |_)  |    |  |  |  | |  ,----'|  '  /
    \   \       |  |      /  /_\  \   |      /            \   \       |  |     |      /     |  |  |  | |  |     |    <
.----)   |      |  |     /  _____  \  |  |\  \----.   .----)   |      |  |     |  |\  \----.|  `--'  | |  `----.|  .  \
|_______/       |__|    /__/     \__\ | _| `._____|   |_______/       |__|     | _| `._____| \______/   \______||__|\__\
                _______ .______    __       _______.  ______    _______   _______     __   __
               |   ____||   _  \  |  |     /       | /  __  \  |       \ |   ____|   |  | |  |  _
               |  |__   |  |_)  | |  |    |   (----`|  |  |  | |  .--.  ||  |__      |  | |  | (_)
               |   __|  |   ___/  |  |     \   \    |  |  |  | |  |  |  ||   __|     |  | |  |
               |  |____ |  |      |  | .----)   |   |  `--'  | |  '--'  ||  |____    |  | |  |  _
               |_______|| _|      |__| |_______/     \______/  |_______/ |_______|   |__| |__| (_)
      .______    __  .___________.   .______    __    __    ______  __  ___  _______ .___________.    _______.
      |   _  \  |  | |           |   |   _  \  |  |  |  |  /      ||  |/  / |   ____||           |   /       |
      |  |_)  | |  | `---|  |----`   |  |_)  | |  |  |  | |  ,----'|  '  /  |  |__   `---|  |----`  |   (----`
      |   _  <  |  |     |  |        |   _  <  |  |  |  | |  |     |    <   |   __|      |  |        \   \
      |  |_)  | |  |     |  |        |  |_)  | |  `--'  | |  `----.|  .  \  |  |____     |  |    .----)   |
      |______/  |__|     |__|        |______/   \______/   \______||__|\__\ |_______|    |__|    |_______/
     _______.___________..______       __   __  ___  _______     _______.   .______        ___       ______  __  ___
    /       |           ||   _  \     |  | |  |/  / |   ____|   /       |   |   _  \      /   \     /      ||  |/  /
   |   (----`---|  |----`|  |_)  |    |  | |  '  /  |  |__     |   (----`   |  |_)  |    /  ^  \   |  ,----'|  '  /
    \   \       |  |     |      /     |  | |    <   |   __|     \   \       |   _  <    /  /_\  \  |  |     |    <
.----)   |      |  |     |  |\  \----.|  | |  .  \  |  |____.----)   |      |  |_)  |  /  _____  \ |  `----.|  .  \
|_______/       |__|     | _| `._____||__| |__|\__\ |_______|_______/       |______/  /__/     \__\ \______||__|\__\
     _______.___________.    ___      .______              _______.___________..______       __    __    ______  __  ___
    /       |           |   /   \     |   _  \            /       |           ||   _  \     |  |  |  |  /      ||  |/  /
   |   (----`---|  |----`  /  ^  \    |  |_)  |          |   (----`---|  |----`|  |_)  |    |  |  |  | |  ,----'|  '  /
    \   \       |  |      /  /_\  \   |      /            \   \       |  |     |      /     |  |  |  | |  |     |    <
.----)   |      |  |     /  _____  \  |  |\  \----.   .----)   |      |  |     |  |\  \----.|  `--'  | |  `----.|  .  \
|_______/       |__|    /__/     \__\ | _| `._____|   |_______/       |__|     | _| `._____| \______/   \______||__|\__\
                         ___     ___    __     __                  ___     ___    __   ______
                        |__ \   / _ \  /_ |   / /                 |__ \   / _ \  /_ | |____  |
                           ) | | | | |  | |  / /_       ______       ) | | | | |  | |     / /
                          / /  | | | |  | | | '_ \     |______|     / /  | | | |  | |    / /
                         / /_  | |_| |  | | | (_) |                / /_  | |_| |  | |   / /
                        |____|  \___/   |_|  \___/                |____|  \___/   |_|  /_/
*/

// Convenient macros
#define EVER (;;)
#define DIM(x) (sizeof(x)/sizeof(x[0]))

// Motor data sheet
// 						Output Stage  Output Stage	Output Speed 		Stall Torque 		IME Ticks
// 						Driving Gear	Driven Gear		(RPM)	Output 		(N*m)						per Revolution
//Standard 		10t						32t						100							1.67						627.2
//High Speed	14t						28t						160							1.04						392
//Turbo 			18t						24t						240							0.70						261.333

const int MAX_MOTOR_COMMAND = 127;
const float MAX_RPM = 100.0;	// Standard 393
const float TICKS_PER_RPM = (float)MAX_MOTOR_COMMAND / MAX_RPM;


// Encoder data sheet
//	Quadrature Encoders:	360 ticks per revolution of the output shaft
//	269 Motor IME:	      240.4 ticks per revolution of the output shaft
//	393 Motor IME:	      627.2 ticks per revolution of the output shaft
//	393 High Speed IME:	  392 ticks per revolution of the output shaft
//	393 Turbo Speed IME:	261.333 ticks per revolution of the output shaft

const float TICKS_PER_REVOLUTION = 360.0; // Quadrature (Shaft) Encoder
const float TICKS_PER_DEGREE = TICKS_PER_REVOLUTION / 360.0;
const float DEGREES_PER_TICK = 1.0 / TICKS_PER_DEGREE;

// -------------------------------------------------------------------------
// Arm Control
// -------------------------------------------------------------------------

// The integrated encoders are convenient but in our case the ones we had
// were broken. The quadrature encoders can be used, but experiments with
// the integrated encoder library functions did not produce expected
// results; either just didn't work or produce unexpected answers.
//
// For this reason we will roll our own simple control structure and
// tasks to keep the arm motors well controlled.

// Declare a stuct that represent identification,
// control parameters, and status. Since RobotC
// is C and not C++, we will define separate functions
// rather than encapsulate the desired behavior
typedef struct
{
	tMotor mId;
	tSensors sId;
	float command_deg;
	float encoder_deg;
	float encoder_rpm;
	float kp;
	float ki;
	float kd;
	float kb;
	int pid;
} motorControlType;

// Define operations for the motorControlType (similar to what we might have in C++ so the concepts will port
// easily if ROBOTC ever grows up
void constructMotorControl(motorControlType *this, tMotor mId, tSensors sId, float kp, float ki, float kd, float kb)
{
	this->mId = mId;
	this->sId = sId;
	this->command_deg = 0.0;
	this->encoder_deg = 0.0;
	this->encoder_rpm = 0.0;
	this->kp = kp;
	this->ki = ki;
	this->kd = kd;
	this->kb = kb;
	this->pid = 0;
}

// Each motor can be set to an independent position
// So we provide accessor functions to represent the interface
// This is a practice similar to what is seen in object oriented
// designs rather than allowing direct access to the elements
// This allows us to modify behavior globally instead of needing
// to find all uses

// For every "set" there is a "get" function
void setPosition(motorControlType *this, float aPosition_deg)
{
	this->command_deg = aPosition_deg;
}

// In this case the get function is not the inverse of the set
// Instead we will return the latest encoder position as read
// by the maintainPosition function
float getPosition(motorControlType *this)
{
	return this->encoder_deg;
}

void resetPosition(motorControlType *this)
{
		SensorValue[this->sId] = 0;	// Use the shaft encoder rather than integrated encoders
}

// A function to actually apply the control to each motor
void maintainPosition(motorControlType *this)
{
	long encoder_tick = SensorValue[this->sId];		// Using shaft encoders for the moment
	this->encoder_rpm  = 0.0;	  // TODO: No derivative control at this time


	this->encoder_deg = encoder_tick * DEGREES_PER_TICK;
	float error_deg = this->command_deg - this->encoder_deg;
	if (abs(error_deg) > 0)
	{
		// make the speed proportional to the error
	  int lastPidSign = (this->pid != 0)? this->pid/abs(this->pid) : 1;
	  this->pid = (int)(this->kp * error_deg) + lastPidSign*(int)(this->kd * this->encoder_rpm); // truncate to integer
	  if (this->pid > MAX_MOTOR_COMMAND)
	  {
	  	this->pid = MAX_MOTOR_COMMAND;
	  }
	  else if (this->pid < -MAX_MOTOR_COMMAND)
	  {
	  	this->pid = -MAX_MOTOR_COMMAND;
	  }
	  motor[this->mId] = this->pid;
	}
	else
	{
		// When within the target tolerance, stop.
		motor[this->mId] = 0;
	}
}

// ------------------------------------------------------------
// ------------------------------------------------------------
// A set of the motors we want to position control during the armControl task
struct motorControlType armMotors[2];

// Functions to create and control arm motors as single call
bool armMotorsConstructed = false;
void constructArmMotorControls(void)
{
	if ( ! armMotorsConstructed)
	{
		constructMotorControl(&armMotors[0],arm1,    shaft, 2.0, 0.0, 0.0, 0.0);	// Only proportional control at this time
		constructMotorControl(&armMotors[1],arm2,    shaft, 2.0, 0.0, 0.0, 0.0);

		armMotorsConstructed = true;
	}
}

void resetArmPosition(void)
{
	for (int i = 0; i < DIM(armMotors); ++i)
	{
		resetPosition(&armMotors[i]);
	}
}

void setArmPosition(float angle_deg)
{
	// Hog the CPU while setting all the positions
  // to ensure they change atomically even for the high priority
  // task
	hogCPU();

	for (int i = 0; i < DIM(armMotors); ++i)
	{
		setPosition(&armMotors[i], angle_deg);
	}

	releaseCPU();
}


void maintainArmPosition(void)
{
	for (int i = 0; i < DIM(armMotors); ++i)
	{
		// Assume that arm position is controlled at high priority
		// eliminating the need to hog the CPU
		maintainPosition(&armMotors[i]);
	}
}



// Let the motor position control run as a concurrent activity
// to drive and joystick functions; this allows some control over
// priority to ensure position control is tight
bool armControlInitialized = false;
const long ARM_CONTROL_PERIOD_MSEC = 1;
unsigned int armCount = 0;
task armControl()
{
	if ( ! armControlInitialized)
	{
		resetArmPosition();
		armControlInitialized = true;
	}

	for EVER
	{
		maintainArmPosition();

#ifdef TEST_SIM
    // only display in emulator
		displayLCDNumber(0, 2, (armCount++)%100, 3);
#endif

		wait1Msec(ARM_CONTROL_PERIOD_MSEC);	// Let lower priority tasks execute before resuming control
	}
}


// -----------------------------------------------------------------------------
// Drive Control
// -----------------------------------------------------------------------------

int linear[129] =
{
	0, 0, 18, 18, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20,
	21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 23, 23, 24, 24, 24, 25, 25, 25,
	25, 26, 26, 26, 26, 27, 27, 27, 27, 28, 28, 29, 29, 29, 29, 30, 30, 30,
	31, 31, 31, 32, 32, 33, 33, 33, 34, 34, 35, 35, 36, 36, 36, 37, 37, 38,
	38, 39, 39, 40, 40, 41, 41, 41, 42, 43, 43, 44, 44, 45, 45, 46, 47, 48,
	49, 49, 50, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 61, 62, 64, 65, 66,
	67, 68, 69, 70, 72, 73, 75, 76, 77, 79, 81, 83, 84, 84, 85, 85, 86, 86,
	87, 87, 88, 90, 96, 105, 105
};

int linearize(int vel)
{
	int pwm;

	if (vel > MAX_MOTOR_COMMAND)
	{
		vel = MAX_MOTOR_COMMAND;
	}
	if (vel < -MAX_MOTOR_COMMAND)
	{
		vel = -MAX_MOTOR_COMMAND;
	}
	if (vel < 0)
	{
		pwm = -linear[-vel];
	}
	else
	{
		pwm = linear[vel];
	}
	return pwm;
}

int deadband(int vel)
{
	return ((abs(vel) < 24) ? 0 : vel);
}

// Drive control is a separate task to ensure that we can add additional
// control functions independently of the input commands from drive speed
// and turn coefficient
int const DRIVE_SPEED_CONTROL_PERIOD_MSEC = 20;  // number of milliseconds per each control loop
int const MAX_STEER = 50; // percent of drive to apply to steering

int driveSpeed = 0; //The forward drive speed.
int turnCoef = 0; //The turning amount.
unsigned int driveCount = 0;
task driveSpeedControl()
{
	for EVER
	{
		// Linearizing will also limit the output
	  const int STEER = (MAX_STEER * turnCoef / 100);

	  // Minimize latency while hogging CPU
	  const int LEFT = linearize(driveSpeed + STEER);
	  const int RIGHT = linearize(driveSpeed - STEER);

	  // Hogging CPU here ensures that all 4 motors receive
	  // commands "atomically"
	  hogCPU();
		motor[backLeft] = motor[frontLeft] = LEFT;
		motor[backRight] = motor[frontRight] = RIGHT;
		releaseCPU();

#ifdef TEST_SIM
    // only display in emulator
		displayLCDNumber(0, 8, (driveCount++)%100, 3);
#endif

		wait1Msec(DRIVE_SPEED_CONTROL_PERIOD_MSEC);
	}
}

// drive position control is only used during autonomous and
// other similar demos to process command sequences maintaining the
// heading and field position
task drivePositionControl()
{
	// TODO: Insert code similar to arm control but this time
  // we will keep track of (x,y) and heading, stopping only
  // when both are achieved
}

////////////////////////////////////////////////////////////////////////////////////////
//                                                                                    //
//                          Pre-Autonomous Functions                                  //
//                                                                                    //
// You may want to perform some actions before the competition starts. Do them in the //
// following function.                                                                //
//                                                                                    //
////////////////////////////////////////////////////////////////////////////////////////

void pre_auton()
{
	bStopTasksBetweenModes = true;

	constructArmMotorControls();
}

/////////////////////////////////////////////////////////////////////////////////////////
//
//                                 Autonomous Task
//
// This task is used to control your robot during the autonomous phase of a VEX Competition.
// You must modify the code to add your own robot specific commands here.
//
/////////////////////////////////////////////////////////////////////////////////////////

task autonomous()
{
	// Assume arm control and drive controls have been constructed

	// Place the motor control loop at higher priority than the main loop
	// so we can ensure more stable application of time. The motor control
	// loop must sleep long enough for other tasks to get execution time
	short armControlPriority = getTaskPriority(autonomous) + 1;
	startTask(armControl, armControlPriority);

	// Need both drive speed and drive position control during autonomous mode
	startTask(driveSpeedControl);
	startTask(drivePositionControl);

}

/////////////////////////////////////////////////////////////////////////////////////////////////
//                                                                                             //
//                                 User Control Task                                           //
//                                                                                             //
// This task is used to control your robot during the user control phase of a VEX Competition. //
// You must modify the code to add your own robot specific commands here.                      //
//                                                                                             //
/////////////////////////////////////////////////////////////////////////////////////////////////

bool armUp = false;

task usercontrol()
{

	// Assume arm controls and drive controls have been constructed

	// Place the motor control loop at higher priority than the main loop
	// so we can ensure more stable application of time. The motor control
	// loop must sleep long enough for other tasks to get execution time
	short armControlPriority = getTaskPriority(usercontrol) + 1;
	startTask(armControl, armControlPriority);

	// Only need drive speed control in user control mode
	startTask(driveSpeedControl);

	for EVER
	{
		// Read the joysticks for drive control
	  // passing the latest command for the drive speed task
	  // to pick up on next cycle
		driveSpeed = deadband(vexRT[Ch3]);
		turnCoef   = deadband(vexRT[Ch1]);

		// The following is VERY EARLY TEST CODE ONLY
		if (vexRT[Btn5D] == 1)
		{
			if ( ! armUp)
			{

				setArmPosition(120.0);
				armUp = true;
			}
		}
		else
		{
			if (armUp)
			{
				setArmPosition(10.0);
				armUp = false;
			}
		}

		EndTimeSlice();
	}
}

// Take over for VEX main task when testing in emulator
#ifdef TEST_SIM

task main()
{
	//Setup the VEX LCD for displaying tasks
	clearLCDLine(0);
	clearLCDLine(1);
	displayLCDString(0, 0, "0: xx 1: xx");

	pre_auton();

	startTask(autonomous);

	wait1Msec(1000);
	stopTask(autonomous);

	startTask(usercontrol);

	for EVER
	{
		wait10Msec(100);
	}

}

#endif
